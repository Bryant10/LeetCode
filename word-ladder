//主要思想：广度优先搜索。先构造一个字符串队列，并将start加入队列。1.对队列头字符串做单个字符替换
//每次替换后，2.判断是否和end匹配，如果匹配，返回答案；3.没有匹配，则在字典里面查询是否有“邻居字符串”,
//如果有，则将该字符串加入队列，同时将该字符串从字典里删除。重复1的过程，知道和end匹配。如果最后队列
//为空还未匹配到，则返回0.
import java.util.*;
public class Solution {
    public int ladderLength(String start, String end, HashSet<String> dict) {
        Queue<WordInfo> queue=new LinkedList<WordInfo>();
        queue.offer(new WordInfo(start,1));
        dict.remove(start);
        while(!queue.isEmpty()){
            WordInfo info=queue.poll();
            String thisword=info.word;
            int thisDis=info.dis;
            Iterator<String> itr=dict.iterator();
            while(itr.hasNext()){
                String otherword=itr.next();
                if(isNeighbor(thisword,otherword)){
                    if(otherword.equals(end))
                        return thisDis+1;
                    else{
                        queue.offer(new WordInfo(otherword,thisDis+1));
                        itr.remove();
                    }
                }
            }
        }
        return 0;
    }
    
    public boolean isNeighbor(String word1,String word2){
        int diff=0;
        for(int i=0;i<word1.length();i++){
            if(word1.charAt(i)!=word2.charAt(i)){
                diff++;
                if(diff>1)
                    return false;
            }
        }
        return diff==1?true:false;
    }
}
class WordInfo{
    String word;
    int dis;
    WordInfo(String word,int dis){
        this.word=word;
        this.dis=dis;
    }
}
